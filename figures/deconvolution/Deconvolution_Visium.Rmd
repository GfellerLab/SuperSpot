---
title: "BCBA Visium"
author: "Matei Teleman"
date: "2024-08-30"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r}
library(Seurat)
library(SuperSpot)
library(SuperCell)
library(tidyr)
library(tidyverse)
library(igraph)
```


```{r}
BCBA.so = Seurat::Load10X_Spatial("/Users/admin/Documents/BCBA2/"  )
SpatialDimPlot(BCBA.so)
bcba.md <- readxl::read_xlsx("/Users/admin/Documents/BCBA2/label.xlsx") %>% column_to_rownames("...1")


BCBA.so@meta.data <- cbind(BCBA.so@meta.data,bcba.md)

SpatialDimPlot(BCBA.so, group.by = "cell_type")
SpatialDimPlot(BCBA.so, group.by = "louvain_anno")
```

## Deconvolution

```{r}
library(STdeconvolve)
## load built in data
#data(mOB)
pos <- GetTissueCoordinates(BCBA.so)[,c("x","y")]
cd <- GetAssayData(BCBA.so,assay = "Spatial",layer = "count")
annot <- BCBA.so$cell_type
names(annot) <- rownames(BCBA.so@meta.data)
## remove pixels with too few genes
counts <- cleanCounts(cd, min.lib.size = 100)
## feature select for genes
corpus <- restrictCorpus(counts, removeAbove=1.0, removeBelow = 0.05)
## choose optimal number of cell-types
ldas <- fitLDA(t(as.matrix(corpus)), Ks = seq(2, 9, by = 1))
## get best model results
optLDA <- optimalModel(models = ldas, opt = "min")
## extract deconvolved cell-type proportions (theta) and transcriptional profiles (beta)
results <- getBetaTheta(optLDA, perc.filt = 0.05, betaScale = 1000)
deconProp <- results$theta
deconGexp <- results$beta
## visualize deconvolved cell-type proportions
vizAllTopics(deconProp, pos,
             groups = annot, 
             group_cols = rainbow(length(levels(as.factor(annot)))),
            r = 100, lwd = 0.1)	  
```
## Metaspots
```{r}
g = 5 # gamma
n.pc = 1:30 # number of first PC to use
k.knn = 6 # number of neighbors to connect to each spot
pct = 0.6 # percentage of connections to keep

spotPosition <- GetTissueCoordinates(BCBA.so)[,c("x","y")]

print("Creating metaspots")
# By default, SCimplify_SpatialDLS computes distances in a parallalized way. By default, all the available cpus are used. If your computer doesn't support, you can change the number of cpus with the paramater "n.cpu"
MC <- SCimplify_SpatialDLS_v2(X = GetAssayData(BCBA.so,assay = "Spatial",layer = "count") ,
                                     spotPositions = spotPosition ,
                                     col.x = "x",
                                     col.y = "y",
                                     method_similarity = "1",
                                     split_not_connected = TRUE,
                                     method_reduction = "PCA",
                                     gamma = g,
                                     n.dim = n.pc,
                                     method_knn = "1",
                                     k.knn = k.knn,
                                     pct = pct,
                                     method_normalization = "log_normalize")

BCBA.so@meta.data[,str_c("MC_membership_",g)] <- MC$membership %>% as.character()

method_purity <- c("max_proportion", "entropy")[1]
MC$purity <- supercell_purity(
  clusters = BCBA.so@meta.data$cell_type,
  supercell_membership = MC$membership, 
  method = method_purity
)


print(str_c("mean purity is ",mean(MC$purity)))

#We assign each metaspot with its corresponding annotation
MC$cell_type <- supercell_assign(clusters = BCBA.so@meta.data$cell_type,
                                                          supercell_membership = MC$membership,
                                                          method = "absolute")

MC$polygons <- supercell_metaspots_shape(MC = MC,
                                                   spotpositions = spotPosition,
                                                   annotation = "cell_type",
                                                   concavity = 2,
                                                   membership_name = "membership")

SpatialDimPlotSC(original_coord = spotPosition,
                 col.x = "y",
                 col.y = "x",
                 MC = MC,
                 sc.col = "cell_type",
                 sc.col2 = str_c("MC_membership_",g),
                 polygons_col = "polygons",
                 meta_data = BCBA.so@meta.data)+
  coord_fixed()+
  theme_minimal()+
  NoLegend()


```

```{r}
MC_centroids <- supercell_spatial_centroids(MC,spotPositions = spotPosition)

MC.ge <- superspot_GE(MC = MC,
  ge = GetAssayData(BCBA.so,assay = "Spatial",layer = "count"),
  groups = as.numeric(MC$membership),
  mode = "sum"
)

MC.seurat <- supercell_2_Seuratv5(
  SC.GE = MC.ge, 
  SC = MC, 
  fields = c("cell_type")
)
```

## Deconvolution on metaspots
```{r}
library(STdeconvolve)
## load built in data
#data(mOB)
pos_ms <- MC_centroids[,c("x","y")]
cd_ms <- MC.ge
annot_ms <- MC.seurat$cell_type
names(annot_ms) <- rownames(MC.seurat@meta.data)
## remove pixels with too few genes
counts_ms <- cleanCounts(cd_ms, min.lib.size = 100)
## feature select for genes
corpus_ms <- restrictCorpus(counts_ms, removeAbove=1.0, removeBelow = 0.05)
## choose optimal number of cell-types
ldas_ms <- fitLDA(t(as.matrix(corpus_ms)), Ks = seq(2, 9, by = 1))
## get best model results
optLDA_ms<- optimalModel(models = ldas, opt = "min")
## extract deconvolved cell-type proportions (theta) and transcriptional profiles (beta)
results_ms <- getBetaTheta(optLDA_ms, perc.filt = 0.05, betaScale = 1000)
deconProp_ms <- results_ms$theta
deconGexp_ms <- results_ms$beta
## visualize deconvolved cell-type proportions
vizAllTopics(deconProp_ms, pos_ms,
             groups = annot_ms, 
             group_cols = rainbow(length(levels(as.factor(annot_ms)))),
            r = 100, lwd = 0.1)	  
```

```{r}
# proxy theta for the annotated layers
mobProxyTheta <- model.matrix(~ 0 + annot)
rownames(mobProxyTheta) <- names(annot)
# fix names
colnames(mobProxyTheta) <- unlist(lapply(colnames(mobProxyTheta), function(x) {
  unlist(strsplit(x, "annot"))[2]
}))

mobProxyGexp <- counts %*% mobProxyTheta

mobProxyLayerMarkers <- list()

## make the tissue layers the rows and genes the columns
gexp <- t(as.matrix(mobProxyGexp))

for (i in seq(length(rownames(gexp)))){
  celltype <- i
  ## log2FC relative to other cell-types
  ## highly expressed in cell-type of interest
  highgexp <- names(which(gexp[celltype,] > 10))
  ## high log2(fold-change) compared to other deconvolved cell-types and limit to top 200
  log2fc <- sort(log2(gexp[celltype,highgexp]/colMeans(gexp[-celltype,highgexp])), decreasing=TRUE)[1:200]
  
  ## for gene set of the ground truth cell-type, get the genes
  ## with log2FC > 1 (so FC > 2 over the mean exp of the other cell-types)
  #markers <- names(log2fc[log2fc > 1])
  markers <- names(log2fc)
  mobProxyLayerMarkers[[ rownames(gexp)[celltype] ]] <- markers
}

celltype_annotations <- annotateCellTypesGSEA(beta = results$beta, gset = mobProxyLayerMarkers, qval = 1)

celltype_annotations$predictions
```

```{r}
mobProxyTheta_ms <- model.matrix(~ 0 + annot_ms)
rownames(mobProxyTheta_ms) <- names(annot_ms)
# fix names
colnames(mobProxyTheta_ms) <- unlist(lapply(colnames(mobProxyTheta_ms), function(x) {
  unlist(strsplit(x, "annot"))[2]
}))

mobProxyGexp_ms <- counts_ms %*% mobProxyTheta_ms

mobProxyLayerMarkers_ms <- list()

## make the tissue layers the rows and genes the columns
gexp_ms <- t(as.matrix(mobProxyGexp_ms))

for (i in seq(length(rownames(gexp_ms)))){
  celltype_ms <- i
  ## log2FC relative to other cell-types
  ## highly expressed in cell-type of interest
  highgexp_ms <- names(which(gexp[celltype_ms,] > 10))
  ## high log2(fold-change) compared to other deconvolved cell-types and limit to top 200
  log2fc_ms <- sort(log2(gexp[celltype_ms,highgexp_ms]/colMeans(gexp[-celltype_ms,highgexp_ms])), decreasing=TRUE)[1:200]
  
  ## for gene set of the ground truth cell-type, get the genes
  ## with log2FC > 1 (so FC > 2 over the mean exp of the other cell-types)
  #markers_ms <- names(log2fc_ms[log2fc_ms > 1])
  markers_ms <- names(log2fc_ms)
  mobProxyLayerMarkers_ms[[ rownames(gexp_ms)[celltype_ms] ]] <- markers_ms
}

celltype_annotations_ms <- annotateCellTypesGSEA(beta = results_ms$beta, gset = mobProxyLayerMarkers_ms, qval = 1)

celltype_annotations_ms$predictions
```

```{r}
library(Giotto)
sc_ref.mtx <- Read10X("/Users/admin/Downloads/10672250")
meta.d <- readr::read_csv("/Users/admin/Downloads/10672250/metadata.csv") %>% column_to_rownames(var = "...1")
sc_ref <- CreateSeuratObject(counts = sc_ref.mtx,meta.data = meta.d)
rm(sc_ref.mtx)
sc_ref <- NormalizeData(sc_ref)
Idents(sc_ref) <- "Cell_Type_Annotation"
markers.df <- FindAllMarkers(sc_ref)
dwls_signature_matrix <- makeSignMatrixDWLSfromMatrix(matrix = GetAssayData(sc_ref,layer = "data"), sign_gene = markers.df$gene,
cell_type_vector = sc_ref@meta.data$Cell_Type_Annotation)
rm(sc_ref)


path_to_python = "/Users/admin/miniconda3/bin/python"
working_directory = getwd() # this will use your current working directory
my_instructions = createGiottoInstructions(python_path = path_to_python,
                   save_dir = working_directory)
```

```{r}
BCBA.so@meta.data$cell_ID <- rownames(BCBA.so@meta.data)
go <- Giotto::createGiottoObject(expression = GetAssayData(BCBA.so,layer = "count"),spatial_locs = spotPosition,instructions = my_instructions,cell_metadata = BCBA.so@meta.data[,c("cell_ID","cell_type")])
go <- Giotto::normalizeGiotto(go)
Sys.time()
go <- runDWLSDeconv(gobject = go, sign_matrix = dwls_signature_matrix,cluster_column="cell_type")
Sys.time()
spatDeconvPlot(gobject = go, radius = 100, show_image = F, return_plot = TRUE)+
      ggplot2::geom_polygon(data = MC$polygons,
                            ggplot2::aes(x = y, y = x, fill = cell_type, group = membership),
                   alpha = alpha_hull,
                   color = "black",
                   linetype = "solid")	
saveRDS(go,file = paste0(working_directory,"/go.rds"))
go <- readRDS(paste0(working_directory,"/go.rds"))
```

```{r}
MC.seurat@meta.data$cell_ID <- rownames(MC.seurat@meta.data)
go_ms <- Giotto::createGiottoObject(expression = GetAssayData(MC.seurat,layer = "count"),spatial_locs = MC_centroids[,c("x","y")],instructions = my_instructions,cell_metadata = MC.seurat@meta.data[,c("cell_ID","cell_type")])
go_ms <- Giotto::normalizeGiotto(go_ms)
go_ms <- runDWLSDeconv(gobject = go_ms, sign_matrix = dwls_signature_matrix,cluster_column="cell_type")
spatDeconvPlot(gobject = go_ms, radius = 100, show_image = F, return_plot = TRUE)
saveRDS(go_ms,file = paste0(working_directory,"/go_ms.rds"))
go_ms <- readRDS(paste0(working_directory,"/go_ms.rds"))
```

```{r}
deconv.df <- go@spatial_enrichment[["cell"]][["rna"]][["DWLS"]]@enrichDT

sds <- c()
for (m in unique(MC$membership)){
  cell.ids <- names(MC$membership[MC$membership == m])
  deconv.df.sv <- subset(deconv.df, cell_ID %in% cell.ids)
  
  sds.tmps<-matrixStats::colSds(as.matrix(deconv.df.sv[,2:19])) %>% mean()
  sds <- c(sds,sds.tmps)
}
method.ms <- rep("metaspot",length(sds))
boxplot(sds)
```

```{r}
rand.mem <- c()
for (m in unique(names(MC$membership))){
  rand.mem <- c(rand.mem,sample(unique(MC$membership),1))
}
names(rand.mem) <- names(MC$membership)

sds.rd <- c()
for (m in unique(rand.mem)){
  cell.ids <- names(rand.mem[rand.mem == m])
  deconv.df.sv <- subset(deconv.df, cell_ID %in% cell.ids)
  
  sds.tmps<-matrixStats::colSds(as.matrix(deconv.df.sv[,2:19])) %>% mean()
  sds.rd <- c(sds.rd,sds.tmps)
}
method.rd <- rep("random",length(sds.rd))
boxplot(sds.rd)
```

```{r}
sds.df <- tibble(sd = c(sds,sds.rd), method = c(method.ms,method.rd))
ggplot(sds.df)+geom_boxplot(aes(x = method, group = method, y = sd)) + ggpubr::stat_compare_means(mapping = aes(x = method, group = method, y = sd),paired = F,method = "t.test")
```



```{r}
grid.sds <- c()
for (m in unique(grid_memb)){
  cell.ids <- names(grid_memb[grid_memb == m])
  deconv.df.sv <- subset(deconv.df, cell_ID %in% cell.ids)
  
  sds.tmps<-matrixStats::colSds(as.matrix(deconv.df.sv[,2:19])) %>% mean()
  grid.sds <- c(grid.sds,sds.tmps)
}
boxplot(grid.sds)
```

```{r}
sds.df <- tibble(sd = c(sds,sds.rd,grid.sds),method = c(rep("metaspots",length(sds)),rep("random",length(sds.rd)),rep("grid",length(grid.sds))))
ggplot(sds.df %>% dplyr::mutate(method = factor(method, levels = c("metaspots","grid","random"))))+geom_boxplot(aes(x = method, group = method, y = sd))
```


```{r}
rd.sds <- c()
for (t in 1:1000){
  print(t)
  rd.mem <- sample(unname(MC$membership))
  names(rd.mem) <- names(MC$membership)
  for (m in unique(rd.mem)){
  cell.ids <- names(rd.mem[rd.mem == m])
  deconv.df.sv <- subset(deconv.df, cell_ID %in% cell.ids)
  
  rd.sds.tmps<-matrixStats::colSds(as.matrix(deconv.df.sv[,2:19])) %>% mean()
  rd.sds <- c(rd.sds,rd.sds.tmps)
  }
}
boxplot(rd.sds)
```


```{r}
deconv.df <- go@spatial_enrichment[["cell"]][["rna"]][["DWLS"]]@enrichDT
deconv.df.ms <- go_ms@spatial_enrichment[["cell"]][["rna"]][["DWLS"]]@enrichDT
diffs <- c()
dists <- c()
for (m in unique(MC$membership)){
  cell.ids <- names(MC$membership[MC$membership == m])
  deconv.df.sv <- subset(deconv.df, cell_ID %in% cell.ids)
  mean.tmps <- unname(matrixStats::colMeans2(as.matrix(deconv.df.sv[,2:19])))
  ms.df <- as.matrix(deconv.df.ms)[m,2:19] %>% as.numeric()
  #diffs.tmp <- abs(ms.df-mean.tmps)
  #diffs <- c(diffs,diffs.tmp)
  dists.tmp <- dist(rbind(ms.df, mean.tmps))
  dists <- c(dists,dists.tmp)
}
boxplot(dists)
```

```{r}

```

